.TH "packages/Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.0/build/native/include/gtest/internal/gtest-internal.h" 3 "Tue Jun 4 2019" "Context-Free Grammars" \" -*- nroff -*-
.ad l
.nh
.SH NAME
packages/Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.0/build/native/include/gtest/internal/gtest-internal.h
.SH SYNOPSIS
.br
.PP
\fC#include 'gtest/internal/gtest\-port\&.h'\fP
.br
\fC#include <ctype\&.h>\fP
.br
\fC#include <float\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <iomanip>\fP
.br
\fC#include <limits>\fP
.br
\fC#include <map>\fP
.br
\fC#include <set>\fP
.br
\fC#include <string>\fP
.br
\fC#include <vector>\fP
.br
\fC#include 'gtest/gtest\-message\&.h'\fP
.br
\fC#include 'gtest/internal/gtest\-string\&.h'\fP
.br
\fC#include 'gtest/internal/gtest\-filepath\&.h'\fP
.br
\fC#include 'gtest/internal/gtest\-type\-util\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBtesting::internal::ScopedTrace\fP"
.br
.ti -1c
.RI "class \fBtesting::internal::FloatingPoint< RawType >\fP"
.br
.ti -1c
.RI "class \fBtesting::internal::TypeIdHelper< T >\fP"
.br
.ti -1c
.RI "class \fBtesting::internal::TestFactoryBase\fP"
.br
.ti -1c
.RI "class \fBtesting::internal::TestFactoryImpl< TestClass >\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::CodeLocation\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::ConstCharPtr\fP"
.br
.ti -1c
.RI "class \fBtesting::internal::Random\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::CompileAssertTypesEqual< T1, T2 >\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::CompileAssertTypesEqual< T, T >\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::RemoveReference< T >\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::RemoveReference< T & >\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::RemoveConst< T >\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::RemoveConst< const T >\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::RemoveConst< const T[N]>\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::AddReference< T >\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::AddReference< T & >\fP"
.br
.ti -1c
.RI "class \fBtesting::internal::ImplicitlyConvertible< From, To >\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::IsAProtocolMessage< T >\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::EnableIf< bool >\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::EnableIf< true >\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::RelationToSourceReference\fP"
.br
.ti -1c
.RI "struct \fBtesting::internal::RelationToSourceCopy\fP"
.br
.ti -1c
.RI "class \fBtesting::internal::NativeArray< Element >\fP"
.br
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI " \fBproto2\fP"
.br
.ti -1c
.RI " \fBtesting\fP"
.br
.ti -1c
.RI " \fBtesting::internal\fP"
.br
.ti -1c
.RI " \fBtesting::internal::edit_distance\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBGTEST_CONCAT_TOKEN_\fP(foo,  bar)   \fBGTEST_CONCAT_TOKEN_IMPL_\fP(foo, bar)"
.br
.ti -1c
.RI "#define \fBGTEST_CONCAT_TOKEN_IMPL_\fP(foo,  bar)   foo ## bar"
.br
.ti -1c
.RI "#define \fBGTEST_IS_NULL_LITERAL_\fP(x)   (sizeof(::\fBtesting::internal::IsNullLiteralHelper\fP(x)) == 1)"
.br
.ti -1c
.RI "#define \fBGTEST_REMOVE_REFERENCE_\fP(T)   typename ::\fBtesting::internal::RemoveReference\fP<T>::type"
.br
.ti -1c
.RI "#define \fBGTEST_REMOVE_CONST_\fP(T)   typename ::\fBtesting::internal::RemoveConst\fP<T>::type"
.br
.ti -1c
.RI "#define \fBGTEST_REMOVE_REFERENCE_AND_CONST_\fP(T)   \fBGTEST_REMOVE_CONST_\fP(\fBGTEST_REMOVE_REFERENCE_\fP(T))"
.br
.ti -1c
.RI "#define \fBGTEST_ADD_REFERENCE_\fP(T)   typename ::\fBtesting::internal::AddReference\fP<T>::type"
.br
.ti -1c
.RI "#define \fBGTEST_REFERENCE_TO_CONST_\fP(T)   \fBGTEST_ADD_REFERENCE_\fP(const \fBGTEST_REMOVE_REFERENCE_\fP(T))"
.br
.ti -1c
.RI "#define \fBGTEST_MESSAGE_AT_\fP(file,  line,  message,  result_type)"
.br
.ti -1c
.RI "#define \fBGTEST_MESSAGE_\fP(message,  result_type)   \fBGTEST_MESSAGE_AT_\fP(__FILE__, __LINE__, message, result_type)"
.br
.ti -1c
.RI "#define \fBGTEST_FATAL_FAILURE_\fP(message)   return \fBGTEST_MESSAGE_\fP(message, ::\fBtesting::TestPartResult::kFatalFailure\fP)"
.br
.ti -1c
.RI "#define \fBGTEST_NONFATAL_FAILURE_\fP(message)   \fBGTEST_MESSAGE_\fP(message, ::\fBtesting::TestPartResult::kNonFatalFailure\fP)"
.br
.ti -1c
.RI "#define \fBGTEST_SUCCESS_\fP(message)   \fBGTEST_MESSAGE_\fP(message, ::\fBtesting::TestPartResult::kSuccess\fP)"
.br
.ti -1c
.RI "#define \fBGTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_\fP(statement)   if (::\fBtesting::internal::AlwaysTrue\fP()) { statement; }"
.br
.ti -1c
.RI "#define \fBGTEST_TEST_THROW_\fP(statement,  expected_exception,  fail)"
.br
.ti -1c
.RI "#define \fBGTEST_TEST_NO_THROW_\fP(statement,  fail)"
.br
.ti -1c
.RI "#define \fBGTEST_TEST_ANY_THROW_\fP(statement,  fail)"
.br
.ti -1c
.RI "#define \fBGTEST_TEST_BOOLEAN_\fP(expression,  text,  actual,  expected,  fail)"
.br
.ti -1c
.RI "#define \fBGTEST_TEST_NO_FATAL_FAILURE_\fP(statement,  fail)"
.br
.ti -1c
.RI "#define \fBGTEST_TEST_CLASS_NAME_\fP(test_case_name,  test_name)   test_case_name##_##test_name##_Test"
.br
.ti -1c
.RI "#define \fBGTEST_TEST_\fP(test_case_name,  test_name,  parent_class,  parent_id)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef FloatingPoint< float > \fBtesting::internal::Float\fP"
.br
.ti -1c
.RI "typedef FloatingPoint< double > \fBtesting::internal::Double\fP"
.br
.ti -1c
.RI "typedef const void * \fBtesting::internal::TypeId\fP"
.br
.ti -1c
.RI "typedef void(* \fBtesting::internal::SetUpTestCaseFunc\fP) ()"
.br
.ti -1c
.RI "typedef void(* \fBtesting::internal::TearDownTestCaseFunc\fP) ()"
.br
.ti -1c
.RI "typedef int \fBtesting::internal::IsContainer\fP"
.br
.ti -1c
.RI "typedef char \fBtesting::internal::IsNotContainer\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBtesting::internal::edit_distance::EditType\fP { \fBtesting::internal::edit_distance::kMatch\fP, \fBtesting::internal::edit_distance::kAdd\fP, \fBtesting::internal::edit_distance::kRemove\fP, \fBtesting::internal::edit_distance::kReplace\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename T > ::std::string \fBtesting::PrintToString\fP (const T &value)"
.br
.ti -1c
.RI "char \fBtesting::internal::IsNullLiteralHelper\fP (Secret *p)"
.br
.ti -1c
.RI "char(& \fBtesting::internal::IsNullLiteralHelper\fP (\&.\&.\&.))[2]"
.br
.ti -1c
.RI "\fBGTEST_API_\fP std::string \fBtesting::internal::AppendUserMessage\fP (const std::string &gtest_msg, const Message &user_msg)"
.br
.ti -1c
.RI "\fBGTEST_API_\fP std::vector< EditType > \fBtesting::internal::edit_distance::CalculateOptimalEdits\fP (const std::vector< size_t > &left, const std::vector< size_t > &right)"
.br
.ti -1c
.RI "\fBGTEST_API_\fP std::vector< EditType > \fBtesting::internal::edit_distance::CalculateOptimalEdits\fP (const std::vector< std::string > &left, const std::vector< std::string > &right)"
.br
.ti -1c
.RI "\fBGTEST_API_\fP std::string \fBtesting::internal::edit_distance::CreateUnifiedDiff\fP (const std::vector< std::string > &left, const std::vector< std::string > &right, size_t context=2)"
.br
.ti -1c
.RI "\fBGTEST_API_\fP std::string \fBtesting::internal::DiffStrings\fP (const std::string &left, const std::string &right, size_t *total_line_count)"
.br
.ti -1c
.RI "\fBGTEST_API_\fP AssertionResult \fBtesting::internal::EqFailure\fP (const char *expected_expression, const char *actual_expression, const std::string &expected_value, const std::string &actual_value, bool ignoring_case)"
.br
.ti -1c
.RI "\fBGTEST_API_\fP std::string \fBtesting::internal::GetBoolAssertionFailureMessage\fP (const AssertionResult &assertion_result, const char *expression_text, const char *actual_predicate_value, const char *expected_predicate_value)"
.br
.ti -1c
.RI "template<typename T > TypeId \fBtesting::internal::GetTypeId\fP ()"
.br
.ti -1c
.RI "\fBGTEST_API_\fP TypeId \fBtesting::internal::GetTestTypeId\fP ()"
.br
.ti -1c
.RI "\fBGTEST_API_\fP TestInfo * \fBtesting::internal::MakeAndRegisterTestInfo\fP (const char *test_case_name, const char *name, const char *type_param, const char *value_param, CodeLocation code_location, TypeId fixture_class_id, SetUpTestCaseFunc set_up_tc, TearDownTestCaseFunc tear_down_tc, TestFactoryBase *factory)"
.br
.ti -1c
.RI "\fBGTEST_API_\fP bool \fBtesting::internal::SkipPrefix\fP (const char *prefix, const char **pstr)"
.br
.ti -1c
.RI "\fBGTEST_API_\fP std::string \fBtesting::internal::GetCurrentOsStackTraceExceptTop\fP (UnitTest *unit_test, int skip_count)"
.br
.ti -1c
.RI "\fBGTEST_API_\fP bool \fBtesting::internal::AlwaysTrue\fP ()"
.br
.ti -1c
.RI "bool \fBtesting::internal::AlwaysFalse\fP ()"
.br
.ti -1c
.RI "template<class C > IsContainer \fBtesting::internal::IsContainerTest\fP (int, typename C::iterator *=NULL, typename C::const_iterator *=NULL)"
.br
.ti -1c
.RI "template<class C > IsNotContainer \fBtesting::internal::IsContainerTest\fP (long)"
.br
.ti -1c
.RI "template<typename T , typename U > bool \fBtesting::internal::ArrayEq\fP (const T *lhs, size_t size, const U *rhs)"
.br
.ti -1c
.RI "template<typename T , typename U > bool \fBtesting::internal::ArrayEq\fP (const T &lhs, const U &rhs)"
.br
.ti -1c
.RI "template<typename T , typename U , size_t N> bool \fBtesting::internal::ArrayEq\fP (const T(&lhs)[N], const U(&rhs)[N])"
.br
.ti -1c
.RI "template<typename Iter , typename Element > Iter \fBtesting::internal::ArrayAwareFind\fP (Iter begin, Iter end, const Element &elem)"
.br
.ti -1c
.RI "template<typename T , typename U > void \fBtesting::internal::CopyArray\fP (const T *from, size_t size, U *to)"
.br
.ti -1c
.RI "template<typename T , typename U > void \fBtesting::internal::CopyArray\fP (const T &from, U *to)"
.br
.ti -1c
.RI "template<typename T , typename U , size_t N> void \fBtesting::internal::CopyArray\fP (const T(&from)[N], U(*to)[N])"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBGTEST_API_\fP const char \fBtesting::internal::kStackTraceMarker\fP []"
.br
.ti -1c
.RI "class \fBGTEST_API_\fP \fBtesting::internal::ScopedTrace\fP \fBtesting::internal::GTEST_ATTRIBUTE_UNUSED_\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define GTEST_ADD_REFERENCE_(T)   typename ::\fBtesting::internal::AddReference\fP<T>::type"

.SS "#define GTEST_CONCAT_TOKEN_(foo, bar)   \fBGTEST_CONCAT_TOKEN_IMPL_\fP(foo, bar)"

.SS "#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar)   foo ## bar"

.SS "#define GTEST_FATAL_FAILURE_(message)   return \fBGTEST_MESSAGE_\fP(message, ::\fBtesting::TestPartResult::kFatalFailure\fP)"

.SS "#define GTEST_IS_NULL_LITERAL_(x)   (sizeof(::\fBtesting::internal::IsNullLiteralHelper\fP(x)) == 1)"

.SS "#define GTEST_MESSAGE_(message, result_type)   \fBGTEST_MESSAGE_AT_\fP(__FILE__, __LINE__, message, result_type)"

.SS "#define GTEST_MESSAGE_AT_(file, line, message, result_type)"
\fBValue:\fP
.PP
.nf
::testing::internal::AssertHelper(result_type, file, line, message) \
    = ::testing::Message()
.fi
.SS "#define GTEST_NONFATAL_FAILURE_(message)   \fBGTEST_MESSAGE_\fP(message, ::\fBtesting::TestPartResult::kNonFatalFailure\fP)"

.SS "#define GTEST_REFERENCE_TO_CONST_(T)   \fBGTEST_ADD_REFERENCE_\fP(const \fBGTEST_REMOVE_REFERENCE_\fP(T))"

.SS "#define GTEST_REMOVE_CONST_(T)   typename ::\fBtesting::internal::RemoveConst\fP<T>::type"

.SS "#define GTEST_REMOVE_REFERENCE_(T)   typename ::\fBtesting::internal::RemoveReference\fP<T>::type"

.SS "#define GTEST_REMOVE_REFERENCE_AND_CONST_(T)   \fBGTEST_REMOVE_CONST_\fP(\fBGTEST_REMOVE_REFERENCE_\fP(T))"

.SS "#define GTEST_SUCCESS_(message)   \fBGTEST_MESSAGE_\fP(message, ::\fBtesting::TestPartResult::kSuccess\fP)"

.SS "#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement)   if (::\fBtesting::internal::AlwaysTrue\fP()) { statement; }"

.SS "#define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)"
\fBValue:\fP
.PP
.nf
class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\
 public:\
  GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\
 private:\
  virtual void TestBody();\
  static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\
  GTEST_DISALLOW_COPY_AND_ASSIGN_(\
      GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\
};\
\
::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\
  ::test_info_ =\\
    ::testing::internal::MakeAndRegisterTestInfo(\
        #test_case_name, #test_name, NULL, NULL, \
        ::testing::internal::CodeLocation(__FILE__, __LINE__), \
        (parent_id), \
        parent_class::SetUpTestCase, \
        parent_class::TearDownTestCase, \
        new ::testing::internal::TestFactoryImpl<\
            GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\
void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()
.fi
.SS "#define GTEST_TEST_ANY_THROW_(statement, fail)"
\fBValue:\fP
.PP
.nf
GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
  if (::testing::internal::AlwaysTrue()) { \
    bool gtest_caught_any = false; \
    try { \
      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
    } \
    catch (\&.\&.\&.) { \
      gtest_caught_any = true; \
    } \
    if (!gtest_caught_any) { \
      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \
    } \
  } else \\
    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \
      fail("Expected: " #statement " throws an exception\&.\n" \
           "  Actual: it doesn't\&.")
.fi
.SS "#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail)"
\fBValue:\fP
.PP
.nf
GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
  if (const ::testing::AssertionResult gtest_ar_ = \
      ::testing::AssertionResult(expression)) \
    ; \
  else \
    fail(::testing::internal::GetBoolAssertionFailureMessage(\
        gtest_ar_, text, #actual, #expected)\&.c_str())
.fi
.SS "#define GTEST_TEST_CLASS_NAME_(test_case_name, test_name)   test_case_name##_##test_name##_Test"

.SS "#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail)"
\fBValue:\fP
.PP
.nf
GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
  if (::testing::internal::AlwaysTrue()) { \
    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \
    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
    if (gtest_fatal_failure_checker\&.has_new_fatal_failure()) { \
      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \
    } \
  } else \\
    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \
      fail("Expected: " #statement " doesn't generate new fatal " \
           "failures in the current thread\&.\n" \
           "  Actual: it does\&.")
.fi
.SS "#define GTEST_TEST_NO_THROW_(statement, fail)"
\fBValue:\fP
.PP
.nf
GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
  if (::testing::internal::AlwaysTrue()) { \
    try { \
      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
    } \
    catch (\&.\&.\&.) { \
      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \
    } \
  } else \\
    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \
      fail("Expected: " #statement " doesn't throw an exception\&.\n" \
           "  Actual: it throws\&.")
.fi
.SS "#define GTEST_TEST_THROW_(statement, expected_exception, fail)"
\fBValue:\fP
.PP
.nf
GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
  if (::testing::internal::ConstCharPtr gtest_msg = "") { \
    bool gtest_caught_expected = false; \
    try { \
      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
    } \
    catch (expected_exception const&) { \
      gtest_caught_expected = true; \
    } \
    catch (\&.\&.\&.) { \
      gtest_msg\&.value = \
          "Expected: " #statement " throws an exception of type " \
          #expected_exception "\&.\n  Actual: it throws a different type\&."; \
      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
    } \
    if (!gtest_caught_expected) { \
      gtest_msg\&.value = \
          "Expected: " #statement " throws an exception of type " \
          #expected_exception "\&.\n  Actual: it throws nothing\&."; \
      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
    } \
  } else \
    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \
      fail(gtest_msg\&.value)
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for Context-Free Grammars from the source code\&.
